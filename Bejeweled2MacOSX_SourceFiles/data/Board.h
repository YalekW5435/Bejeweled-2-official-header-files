#ifndef __BOARD_H__#define __BOARD_H__#include "../SexyAppFramework/Widget.h"#include "../SexyAppFramework/Point.h"#include "../SexyAppFramework/MTRand.h"#include "../SexyAppFramework/ButtonListener.h"#include "WinDMApp.h"#include "CurvedVal.h"#include "GameStateEngine.h"#include "Points.h"namespace Sexy{class StarField;class WinDMApp;class Graphics;class Font;class DDImage;class MemoryImage;class SoundInstance;class Hyperspace;class PuzzleStateOverlay;class GalaxyMap;class EffectOverlay;class PodButton;class PodDialogButton;class HyperlinkWidget;const int	NUM_COLS = 8;const int	NUM_ROWS = 8;const int SAVEGAME_VERSION = 4;const int PUZZLE_VERSION = 2;const int SOLUTION_VERSION = 2;const int	NUM_WARP_COLS = 48;const int	NUM_WARP_ROWS = 48;enum{	TYPE_GEM_1 = 0,	TYPE_GEM_LAST = NUM_GEM_TYPES-1,		TYPE_ROCK,	TYPE_BOMB,		TYPE_WILDCARD_DESTROYER,	NUM_TYPES};#define LAST_MATCHABLE_TYPE TYPE_GEM_LAST#define NUM_LIGTNING_POINTS 8typedef TPoint<float> FSPoint;class Lightning{public:	FSPoint					mPoints[NUM_LIGTNING_POINTS][2];	float					mPercentDone;	// Direction to pull to at the end	float					mPullX;	float					mPullY; };typedef std::vector<Lightning*> LightningPtrVector;class Light{public:	float					mX;	float					mY;		float					mDiffDiv;	float					mDistSub;	float					mCurIntensity;	bool					mCharging;	float					mChargeRate;	float					mDecayRate;};typedef std::vector<Light> LightVector;class Effect{public:	enum	{		TYPE_EXPLOSION	};public:	int						mType;	int						mX;	int						mY;	int						mFrame;	int						mDelay;public:	Effect();};typedef std::vector<Effect*> EffectPtrVector;class Shard{public:	enum	{		TYPE_GEM_SHARD,		TYPE_ROCK_CHUNK,		TYPE_SPARKLE,		TYPE_SPARK,		TYPE_PLASMA,		TYPE_SNOW	};public:	int						mType;	Color					mColor;		float					mX;		float					mY;		float					mYDelta;	int						mFrame;	int						mUpdateDiv;		float					mVelX;	float					mVelY;	float					mAccelScale;	float					mSparkleChance;	float					mSparkleChanceAdd;		float					mDrawX;	float					mDrawY;	float					mCenterX;	float					mCenterY;	float					mRot;	bool					mIsCyclingColor;	int						mCurHue;	float					mOrigX;	int						mLifeAcc;	int						mSparkNum;	float					mAccY;	bool					mSparkDead;	float					mSparkAlpha;	float					mSparkAngleMult;	float					mSparkWaviness;	float					mSparkDist;public:	Shard();};typedef std::vector<Shard*> ShardPtrVector;enum{	EFFECT_NONE,	EFFECT_WILDCARD_FADE,	EFFECT_GEM_CHARGE};struct Piece{	int						mType;	float					mX;	float					mY;	float					mZ;	int						mCol;	int						mRow;		int						mXVelocity;		float					mFallVelocity;		float					mZVelocity;	float					mZRot;	float					mZRotAdd;	BYTE					mIsElectrocuting;	float					mElectrocutePercent;	float					mLighting[9];		int						mBombCountdown;	int						mLastActiveTick; // Determines which one "changes"	int						mChangedTick;	int						mLastGemType;	int						mOfsX;	int						mOfsY;	BYTE					mBombified;	int						mBombifyTick;	int						mExplodeDelay;	int						mSwapMultX;	int						mSwapMultY;		int						mSwapDirX;	int						mSwapDirY;	BYTE					mShineAnim;	double					mShineFactor;	float					mShineAnimFrame;	BYTE					mShrinking;	int						mShrinkSize;	int						mSpinFrame;	int						mSparkleLife;	int						mSparkleFrame;	int						mSparklePairOfsCol;	int						mSparklePairOfsRow;	int						mEffectNum;	int						mEffectDelay;	float					mEffectPercent;			double					mRot;	double					mRotVel;	double					mRotDist;	public:	Piece();	~Piece();};typedef std::vector<Piece*> PieceVector;/*struct Points{	int						mX;	int						mY;	int						mLife;		int						mPointsFadeNum;	int						mNumPoints;};*/struct WarpPoint{	float					mX;	float					mY;	float					mZ;	float					mVelX;	float					mVelY;	float					mU;	float					mV;	float					mRot;	float					mDist;};#define HYPERWARP_ROWS 7#define HYPERWARP_COLS 7// For hyper gems or whateverstruct HyperWarpPoint{	float					mXOfs; // From upper-left	float					mYOfs;	float					mU;	float					mV;		float					mRot;	float					mDist;	float					mDistMult;};typedef std::vector<Points*> PointsList;typedef std::list<IntPoint> PointList;typedef std::vector<IntPoint> PointVector;typedef std::list<Buffer> BufferList;typedef std::vector<ByteVector> ByteVectorVector;typedef std::vector<ulong> ULongVector;struct SolutionData{	uchar					mNumSolutionMoves;	int						mSolutionMovesIdx;};typedef std::vector<SolutionData> SolutionDataVector;typedef void (*TransformFunc)(ulong* theBits, int theLength);class Board : public Widget, public ButtonListener{	friend class EffectOverlay;public:		enum	{		STATE_FALLING,		STATE_MAKE_MOVE,		STATE_SWAPPING,		STATE_SWAP_INVALID,		STATE_SWAPPING_BACK,		STATE_CLEARING,		STATE_GAME_OVER_ANIM,		STATE_GAME_OVER_DISPLAY,		STATE_LEVEL_COMPLETE_PENDING,		STATE_LEVEL_COMPLETE,				STATE_WHIRLPOOL,		STATE_LEVEL_TRANSITION,		STATE_BOARD_DROPPING,		STATE_INTERFACE_RESTORE,		STATE_LIGHTNING,		STATE_PUZZLE_SWITCHING,		STATE_PUZZLE_COMPLETED,		STATE_PUZZLE_NO_MOVES,		STATE_PUZZLE_AT_END,		STATE_PUZZLE_AT_END_CLOSE,		STATE_PUZZLE_SECRET_DONE,		STATE_SHOWING_GALAXY_MAP,		STATE_GALAXY_MAP,				STATE_HIDING_GALAXY_MAP,			};	enum	{		SHOWSTATE_SHOWING,		SHOWSTATE_SHOWN,		SHOWSTATE_HIDING,		SHOWSTATE_HIDDEN	};	WinDMApp*				mApp;	PuzzleStateOverlay*		mPuzzleStateOverlay;	GalaxyMap*				mGalaxyMap;	EffectOverlay*			mEffectOverlay;	GameStateEngine			mGameStateEngine;	MTRand					mRand;	int						mLevel;	int						mDispLevel;	Piece*					mBoard[NUM_ROWS][NUM_COLS];	int						mLastColExplodeTick[NUM_COLS];	int						mState;		bool					mHadInitialBackdropProcessing;	int						mShowState;	bool					mProcessedEndGameInfo;	bool					mClassicMode;	BYTE					mTimedMode;		BYTE					mPuzzleMode;	bool					mEndlessMode;	BYTE					mSecretMode;	BYTE					mTwilightMode;	BYTE					mInsaneMode;	BYTE					mDoubleSpeed;	BYTE					mGravityReversed;	BYTE					mCreateMode;	BYTE					mFreeMove;	bool					mDebugMessages;	BYTE					mWasModeUnlocked;	SoundInstance*			mWhirlpoolSound;			BYTE					mFirstMove;	int						mFallDelay;	std::string				mLastFileName;	FSRef					mLastFileParent;	bool					mFirstDraw;	bool					mWantResync;	HyperlinkWidget*		mEndHyperlink;	PodButton*				mMenuButton;	PodButton*				mHintButton;	PodButton*				mButton2;	int						mGoDelay;	int						mShowLevelDelay;	int						mFramesPlayed;	bool					mRestartMusic;		// For secret puzzle mode	int						mPuzzleStartPoints;	StringVector			mPuzzlePaths;	std::string				mCurPuzzleFile;	int						mSecretTotalPuzzles;	int						mSecretPuzzlesSolved;		int						mPlanetPuzzlesSolved;	int						mEndlessNumRainbowGems;	int						mEndlessNumOuterGems;	int						mEndlessNumInnerGems;	int						mEndlessSparkleOuter;	int						mEndlessSparkleInner;	int						mEndlessSparkleLife;	PodDialogButton*		mTutorialShowAgainButton;	PodDialogButton*		mTutorialContinueButton;		bool					mPowerGlowOn;	int						mPowerGlowDelay;	int						mPowerGlowX;	int						mPowerGlowY;	float					mPowerGlowEffectPercent;	CurvedVal				mGalaxyShowOffset;		CurvedVal				mInterfaceOffset;	bool					mShowingSun;	float					mSunPosition;	bool					mNoMoreMoves;	double					mResetHintAngle;	double					mTimerBarHintAngle;	Buffer					mCreateState;	BufferList				mUndoBuffers[2];	int						mUndoOffset[2];			ulong					mSolutionBoardHash;	ULongVector				mSolutionMovesBuffer;	SolutionDataVector		mSolutionData; // Index by board state num	std::string				mLastSolutionName;	bool					mPuzzleMirrored;	int						mSolutionCurStateNum;		int						mSolutionIntialStateNum;	bool					mSolutionValid;	int						mNumValidMoves; // Number of valid moves from current state		uchar					mNextMoveByte;	int						mCurMoveHintCount;	int						mPuzzlePodOver;	int						mDeferredPodNum;		int						mDeferredPlanetCount;	int						mPuzzleEndHintDelay;	int						mPuzzlePlayTicks;	int						mPuzzleHintCount;	bool					mAtPuzzleEnd;	bool					mInTutorialMode;	StringVector			mTutorialText;	PointVector				mTutorialMoves;	int						mTutorialMoveNum;	float					mLastMoveAlpha;	float					mThisMoveAlpha;		bool					mLastPowergemWasL;	BYTE					mSeenPowergemHint;	BYTE					mSeenHypercubeHint;		Piece*					mHintPiece;	float					mHintAngle;	Piece*					mSelectedPiece;	int						mSelectAnimCnt;	bool					mShowingFirstMove;	int						mArrowBob;	int						mArrowBobAdd;	int						mFirstMovePieceCol;		int						mFirstMovePieceRow;	int						mSecondMovePieceCol;	bool					mIsLightningSwap;	Piece*					mFirstPiece;	Piece*					mSecondPiece;	float					mSelectorAlpha;	int						mSwapAngle;	int						mSwapCenterX;	int						mSwapCenterY;	int						mDispBarLen;	int						mTicksPlayed;	WarpPoint				mWarpPoints[NUM_WARP_ROWS][NUM_WARP_COLS];	float					mWarpSpeed;		int						mWarpDelay;	int						mUISuckDelay;	float					mWarpSizeMult;	CurvedVal				mUIWarpPercentAdd;	double					mUIWarpPercent;	bool					mFirstWhirlDraw;		int						mFlashDelay;	int						mHyperspaceDelay;	double					mFlashPercent;	Hyperspace*				mHyperspace;	float					mInterfaceRestorePercent;		int						mLightningMatchType;	ulong					mTimePeriodStart;	int						mTimePlayedAdd;	int						mTotalGameTime;	int						mTotalGameTimeCommitted;	int						mNoMoveCount;	int						mPoints;	double					mPointMultiplier;	double					mTimedBonus;	double					mTimedBonusMult;	int						mDispPoints;		int						mGemsCleared;	int						mGemsClearedCommitted;	int						mMoveClearCount;	int						mChainCount;	int						mLastHitSoundTick;	int						mShakeLife;	float					mQuakeAmplitude;	float					mQuakeLife;		int						mScrOfsX;	int						mScrOfsY;	int						mLongestChainReaction;	int						mHighestScoringMove;	int						mMoveExplosionCount;	bool					mHadExplosion;	int						mNumPowerGemsCreated;	int						mNumPowerGemsCreatedCommitted;	int						mNumHyperGemsCreated;	int						mNumHyperGemsCreatedCommitted;			ulong					mLastHypergemDestroyTick;		int						mDispMovePoints;	int						mMovePoints;	int						mMovePointsLife;	double					mDispMoveFade;	bool					mDoHintPenalty;			/*int						mHintLife;	int						mHintPointX;	int						mHintPointY;	float					mHintAlpha;*/	bool					mDirectShowHint;	int						mLastHintFirstCol;	int						mLastHintFirstRow;	int						mLastHintSecondCol;	int						mLastHintSecondRow;		bool					mNewGameClicked;			int						mPauseCount;		int						mVisPauseCount;		PointsList				mPointsList;	Font*					mFloatPointsFont;	Font*					mScoreFont;		BYTE					mInBonus;	int						mBonusCount;	int						mLastQuakePoints;	int						mNextQuakePoints;	int						mPointsPerQuake;	double					mBonusPenalty;	double					mTimedPenaltyVel;	double					mTimedPenaltyAccel;	double					mTimedPenaltyJerk;	bool					mFlashBarRed;	int						mTimerBarNum;	ulong					mLastWarningSound;	bool					mExternalDraw;	int						mLastMouseX;	int						mLastMouseY;	int						mMouseDownX;	int						mMouseDownY;	bool					mMouseDown;	int						mMouseIgnoreDelay;	DDImage*				mBkgImage;		//bool					mBkgDirty;	DDImage*				mTempScoreImage;	DDImage*				mTempUIImage;	DDImage*				mTempBoardImage;	bool					mConvertingBkg;	MemoryImage*			mLevelGlowImage;			DDImage*				mCurBackdrop;	DDImage*				mNextBackdrop;		DDImage*				mBackgroundCacheImage;	MemoryImage*			mBombifyCacheImage;	BYTE					mHandleBombs;	bool					mCacheImageDirty;	bool					mPreparingLevelImages;	int						mNextPlanetNum;	int						mLevelBounceCountdown;	int						mBackdropNum;	int						mBackdropLoadDelay;						int						mTransitionPos;	int						mElectOffset;	float					mWhirlpoolFrame;	int						mTimerDelay;	double					mWhirlpoolFade;	double					mWhirlpoolRot;	double					mWhirlpoolRotAcc;	BYTE					mShowedLevelThing;		float					mGemShowPct;	float					mEffectShowPct;	float					mPauseFade;	bool					mShowPause;	double					mStarRot;	double					mStarRot2;	double					mStarFade;	double					mStarFade2;		LightningPtrVector		mLightningVector;	EffectPtrVector			mEffectVector;	ShardPtrVector			mShardVector;	LightVector				mLightVector;	bool					mSlowMode;	int						mBonusLevelCur;	int						mBonusLevelWant;	int						mBonusDelay;	int						mLastGoodUpdate;	HyperWarpPoint			mHyperWarpPoints[HYPERWARP_ROWS][HYPERWARP_COLS];	std::string				mCheatString;	bool					mUseOldGems;	bool					mXMasMode;	bool					mNeedReload;		bool					mHalfSpeed;	bool					mGameInvalid;	TransformFunc			mLevelTransformFunc;	bool					mNauseaMode;	StarField*				mStarField;	bool					mNoFrameMode;protected:	void					ProcessEndGameInfo();	void					ImageTransform(MemoryImage* theImage, TransformFunc theTransformFunc);	void					TransformAllImages(TransformFunc theTransformFunc);	void					ClearUndoBuffers();	void					SaveState(Buffer* theBuffer);	void					LoadState(const Buffer* theBuffer);	void					MarkForUndo();	void					PopUndo();	bool					CanUndo();	void					Undo();	void					UndoAll();	void					Redo();	void					EnableCreateMode(bool enabled);	void					DoPoints(int theNumPoints, int theX, int theY, const Color& theColor);	void					KillPoints();	Effect*					AllocEffect();	void					FreeEffect(Effect* theEffect);	void					AddAlphaSparkle(int theX, int theY, MemoryImage* theAlphaImage, int theWidth, int theHeight);	int						GetColX(int theCol);	int						GetRowY(int theRow);	int						GetColAt(int theX);	int						GetRowAt(int theY);	void					ColorizeImage(MemoryImage* theImage, const Color& theColor);	void					PrepareTintedImages();	void					StartPrepareLevelImages();	static void				PrepareLevelImagesStub(void* theParam);	void					PrepareLevelImages();	void					ProcessLevelImages();	void					SetupLevelData();	void					NewBoard();	bool					HasSet();	bool					FindSets();	Piece*					GetPieceAt(int theX, int theY);	Piece*					MakePieceAt(int theX, int theY);	void					GameOver(int aShakeLife);		bool					FindMove(int* theCoords, int theMoveNum, bool horz, bool vert);	int						GetPanPosition(int theX);	bool					WillBeValidSwap();	bool					MovePiece(Piece* thePiece1, int theDirX, int theDirY);	void					SwapPieces(Piece* thePiece1, Piece* thePiece2);	void					DoHyperspace();	void					CreateTemp3dImages();	void					DoWhirlpool();	void					GetBoardSize(int* theWidth, int* theHeight);	void					GetBoardCenter(int* theX, int* theY);			void					ShowHint();	void					PuzzleCompleted();	void					KillTutorialButtons();	void					NextTutorialMove();	void					CommitSwap();	void					DoneClearing();		void					SmallExplodeAt(int theCol, int theRow);	void					ExplodeAtHelper(int theCol, int theRow);	void					ExplodeAt(int theCol, int theRow);	void					ExplodingFinished();	std::string				GetPrintableState();	ulong					GetStateHash();	void					AddLightning(int theStartX, int theStartY, int theEndX, int theEndY);	void					ClearLightning();	void					CheckForHints();	void					UpdateFalling();	void					UpdateSwapping();	void					UpdateClearing();	void					UpdateGameOverAnim();		void					UpdateWhirlpool();	void					EndWhirlpool();	void					EndInterfaceRestore();	void					UpdateLevelTransition();	void					UpdateBoardDropping();		void					UpdateLightning();		void					UpdateStarRots();	bool					UpdateExplodeDelays();	void					UpdateHyperWarpPoints();	void					UpdateBonusPenalty();		void					UpdateSecretUnlocked();	void					DoUpdate();		void					AddPointLight(float theX, float theY, float theDiffDiv, float theDistSub, float theIntensity, Piece* thePieceIgnore, bool ignorePowergems);	void					UpdateEffects();	void					DrawEffects(Graphics* g, bool drawSparks = false);	void					DrawWidgetTo(Graphics* g, Widget* theWidget);	void					DrawBoard(Graphics* g, bool noBack = false, bool noFront = false);	void					DrawScore(Graphics* g, bool noBack = false, bool noFront = false);		void					DrawUI(Graphics* g, bool noBack = false, bool noFront = false);	void					DrawLightning(Graphics* g);	void					Draw3DWhirlpoolState(Graphics* g);	void					Draw3DInterfaceRestoreState(Graphics* g);	void					DrawNormal2d(Graphics* g);	void					DrawNormal(Graphics* g);	void					ResizeButtons();public:	Board(WinDMApp* theApp);	virtual ~Board();		virtual void			MouseMove(int x, int y);	virtual void			MouseLeave();	virtual void			MouseDown(int x, int y, int theClickCount);	virtual void			MouseUp(int x, int y, int theClickCount);	virtual void			MouseDrag(int x, int y);	virtual void			MouseWheel(int theDelta);	virtual void			KeyChar(char theChar);	virtual void			Update();		virtual	void			Draw(Graphics* g);		virtual void			AddedToManager(WidgetManager* theWidgetManager);	virtual void			RemovedFromManager(WidgetManager* theWidgetManager);	virtual void			SetVisible(bool visible);	void					DrawWavyImage(Graphics *g, Image *theImage, int xoff, int yoff, float theAmplitude);	void					DrawLevelText(Graphics* g);	void					CreateFontGlowImages();	void					DrawAllToBackgroundCache();	ulong					GetBoardHash();		int						FindPuzzleValidMoves(ulong* theValidMoves, int theMaxValidMoves);		void					DeferredSelectPuzzlePod(int thePuzzlePod);	void					SelectPuzzlePod(int thePuzzlePod);	void					ShowPlanetCount();	void					UpdateSolvability();	void					UndoUntilSolvable();	void					UpdateSolutionValidity();			void					SolutionCommitMove(uchar theMoveNum);	void					StabilizeState();	void					ClearBoard();	bool					IsBoardClear();	void					NewGame();	bool					IsInProgress();	static bool				HasSavedGame();	bool					LoadGame();	bool					SaveGame();	static std::string		GetSavedGameFileName();	bool					SavePuzzle(FSRef* parentRef, const std::string& theFileName);		bool					LoadSolution(const std::string& theFileName);	void					MakePuzzleCrazy();	bool					LoadPuzzle(const std::string& theFileName, FSRef* parentRef = NULL);	static bool				LoadPuzzleThumb(const std::string& theFileName, int theBoard[NUM_ROWS][NUM_COLS]);	void					LoadNextSecretPuzzle();	bool					DeleteSavedGame();		void					InitialBackdropProcessing();	void					Show();	void					ShowNow();	void					Hide();	void					HideNow();	void					Pause(bool visible);	void					Unpause(bool visible);	void					TryShowHint();			void					ClearPieceHints();	void					ShowPuzzleHint();		uchar					TranslateMoveByte(uchar theByte);	void					ShowNextPuzzleMove();	void					NextEndlessLevel();	void					ShowGalaxyMap();	void					HideGalaxyMap();	virtual void			ButtonPress(int theId);		virtual void			ButtonDepress(int theId);};}#endif //__BOARD_H__